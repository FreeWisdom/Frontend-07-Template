# 学习笔记
## 字符串分析算法

### 1、字典树
* 前缀树，又称字典树，是N叉树的特殊形式。
* 前缀树的一个重要的特性是：节点所有的后代都与该节点相关的字符串有着共同的前缀。这就是前缀树名称的由来。
* 一个前缀树是用来存储字符串的。前缀树的每一个节点代表一个字符串（前缀）。
* 每一个节点会有多个子节点，通往不同子节点的路径上有着不同的字符。
* 子节点代表的字符串是由节点本身的原始字符串，以及通往该子节点路径上所有的字符组成的。
* 应用：可用于大量高重复字符串的存储与分析，例如自动补全，拼写检查等。
* 根节点表示空字符串。下图是一个前缀树例子：<img src='https://cdn.nlark.com/yuque/0/2020/png/114317/1608616953848-d82bd389-e454-48ca-90db-03d563209c4c.png?x-oss-process=image%2Fresize%2Cw_600'>

### 2、KMP
#### 2.1、串的朴素模式匹配算法
* 模式匹配：在主串中找到与模式串相同的子串，并返回其所在位置；
<img src='https://cdn.nlark.com/yuque/0/2020/gif/114317/1608623203567-10a28cb2-d2c9-413b-8ec7-3a25afbaf3b4.gif'>
<img src='https://cdn.nlark.com/yuque/0/2020/gif/114317/1608623213565-6244935a-1bb3-4c5a-b1d7-2e306ca1a877.gif'>
<img src='https://cdn.nlark.com/yuque/0/2020/gif/114317/1608623225023-c4edfd30-60cc-4cf7-ac36-fee71542b79b.gif'>

* 如上三图所示，在进行每一轮匹配时，总是会重复对A进行比较。对于S中的每个字符，我们都需要从T第一个位置重新开始比较，且 ***子串与模式串部分匹配，S前面的A越多，浪费的时间也就越多，反之KMP并不比朴素模式优化***；
* 假设 S 的长度为 m，T 的长度为 n，理论上讲，最坏情况下迭代 m - n + 1 轮，每轮最多进行 n 次比对，一共比较了 (m - n + 1) × n 次，当 m >> n 时，渐进时间复杂度为 O(mn)。

#### 2.2、串的KMP算法
* 串的KMP算法是串的朴素模式匹配算法的优化；
* Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，以三人名字首字母命名；
* 核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的，字符序列越长，该算法的优势越明显；
    - ***当子串和模式串不匹配时，主串指针`i`不回溯，模式串指针`j = next[i]`回溯；***
* 它的平均时间复杂度是 O(m + n)；
* 如下三图所示，注意，按照原来的思路，我们下一步应将字符串 P 的开头，与字符串 S 的第二位 C 重新进行比较。而 KMP 算法告诉我们，我们只需将字符串 P 需要比较的位置重置到图中 j 的位置，S 保持 i 的位置不变，接下来即可从 i，j 位置继续进行比较。
<img src='https://cdn.nlark.com/yuque/0/2020/png/114317/1608627293838-7178c6c6-27c6-4ca4-9e8c-3fc53098ac33.png'>
<img src='https://cdn.nlark.com/yuque/0/2020/gif/114317/1608627304610-7504f97c-5972-45d6-8638-d686d17577cb.gif'>
<img src='https://cdn.nlark.com/yuque/0/2020/png/114317/1608627306703-f3174f42-9dcf-4393-85b3-1f7c515d1609.png'>

##### 2.2.1、模式串的next数组
* next数组的写法大概有四种，也同时存在4中不同的kmp匹配的相应方法，本文档介绍的为：第一个都是0的基础上，其他各位均加一，求得next数组；本文件夹内的同步代码中不用加一；
* 构造方法为：next[i] 对应的下标，为 P[0...i - 1] 的最长公共前缀后缀的长度，令 P[0] = -1。
* 前缀与后缀
    - 例：对于字符串 abcba
    - 前缀：它的前缀包括：a, ab, abc, abcb，不包括本身；
    - 后缀：它的后缀包括：bcba, cba, ba, a，不包括本身；
    - 最长公共前缀后缀：abcba 的前缀和后缀中只有 a 是公共部分，字符串 a 的长度为 1。
<img src='https://cdn.nlark.com/yuque/0/2020/png/114317/1608632289341-ebf39d8a-856e-4a88-a3be-263637f8f2ec.png'>

* 如上图，我们将 P[0...i - 1] 的最长公共前后缀的长度作为 next[i] 的下标，就得到了 next 数组。
    - 若按照如下手算方法的该next数组为：`[0, 1, 1, 1, 1, 1, 2, 3]`，数组中的每一位，都比上面的方法多加一；
* 如下图，根据模式串，得到 next[i] 数组的动画过程。
<img src='https://cdn.nlark.com/yuque/0/2020/gif/114317/1608632140192-fbe44f02-77b8-4c52-b57a-e67729d29749.gif'>

* next数组手算方法：***当第`j`个字符匹配失败，由前`1 ~ j - 1`个字符组成的串记为`S`，则`next[j] = (S的最长相等前后缀长度 + 1) || (S的最长相等前后缀长度)`，特别的`next[1] = 0``next[2] = 1`;***
    - 例：模式串`ababaa`

|  序号j   | 1  | 2  | 3  | 4  | 5  | 6  |
|  -----  | -  | -  | -  | -  | -  | -  |
| 模式串   | a  | b  | a  | b  | a  | a  |
| next[j] | 0  | 1  | 1  | 2  | 3  | 4  |

#### 2.3、KMP算法的优化
* KMP算法存在的问题
    - 如下图，第一张图到第二张图的几次对比，模式串的移动中，几次模式串中重复的a与主串中c的对比没有意义，多余；
* KMP算法优化
    - 当子串和模式串不匹配时`j = nextval[j]`
<img src='https://cdn.nlark.com/yuque/0/2020/png/114317/1608637974568-60f93251-690e-4dc3-bc41-3f9d1b42486a.png'>
<img src='https://cdn.nlark.com/yuque/0/2020/png/114317/1608637976624-7e1d6fe7-7a95-482b-8fdf-103646e852c6.png'>
<img src='https://cdn.nlark.com/yuque/0/2020/png/114317/1608639216526-28b9d037-3c83-447c-9699-72569655d3e9.png'>

### 3、wildcard
* 带通配符的字符串模式
* `"ab*cd*abc*a?d"`该字符串中不同“*”的匹配规律：
    - 前两个“*”，应该尽量少的匹配字符；
    - 最后一个“*”，应尽量多的匹配字符；
    - 特殊的两端的两段，开头的"ab"只匹配开头的几个字符（如“ab..”），结尾的“a?d”只匹配结尾的几个字符（如“..a?d”）；
    - "*cd"在源字符串里找cd字符，“*abc”在原字符串找abc字符；
* ***注~~~谨记！！！：目前跟着视频的这种写法，针对LeetCode-44. Wildcard Matching有些测试用例跑不通，最后一句倒着判断的逻辑还待有机会完善；***
### 4、正则
* 字符串通用模式匹配
### 5、状态机
* 通用字符串分析
### 6、LL LR
* 字符串多层级结构分析

